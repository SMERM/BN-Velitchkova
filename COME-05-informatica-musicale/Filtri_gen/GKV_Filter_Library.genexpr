//=====================================
//=====================================
// FILTER LIBRARY
// by Gabriela Krassimirova Velitchkova
// 2020
//=====================================
//=====================================
//               CONTENT
//=====================================
//=====================================
// 1. ONEPOLE_LOWPASS
//    - onepole(Xn, freqcut)
//
// 2. BIQUAD
//    -  biquad(Xn, a0, a1, a2, b1, b2)
//
// 3. ALLPASS
//    - allpass_T60(Xn, ms, T60)
//    - allpass_gain(Xn, ms, gain)
//
// 4. COMB FILTER
//    - comb_iir(Xn, ms, gain)
//    - comb_fir(Xn, ms, gain)
//    - fbcomb(Xn, ms, gain)
//    - fbcomb_lp(Xn, ms, T60, freqcut)
//    - fbcomb_lp_all(Xn, ms, T60, freqcut)
//
//=====================================
//=====================================
//
//
//=====================================
//  1.
//=====================================
//  ONEPOLE_LOWPASS
//=====================================
//=====================================

onepole(Xn, freqcut)
{
History history_1(0);
omega = ((freqcut * twopi)) / samplerate;
cosw = cos(omega);
cosq = cosw * cosw;
alpha = (cosw - 1.) + (sqrt((cosq - (4. * cosw)) + 3.));
mul_1 = (1. - alpha) * history_1;

  Yn = mul_1 + (Xn * alpha);

history_1_2 = fixdenorm(Yn);
history_1 = history_1_2;

    return Yn;
}

//=====================================
//  2.
//=====================================
//  BIQUAD
//=====================================
//=====================================

biquad(Xn, a0, a1, a2, b1, b2)
{
History history_1(0);
History history_2(0);
History history_3(0);
History history_4(0);

mul_1 = Xn * a0; // FF input gain
mul_2 = history_1 * a2; // FF coeff.2
mul_3 = history_3 * a1; // FF coeff.1
mul_4 = history_4 * b1; // FB coeff.1
mul_5 = history_2 * b2; // FB coeff.2

Yn = (mul_1 + mul_2 + mul_3) - (mul_4 + mul_5);

history_1_next_11 = fixdenorm(history_3);
history_2_next_12 = fixdenorm(history_4);
history_3_next_13 = fixdenorm(Xn);
history_4_next_14 = fixdenorm(Yn);

history_1 = history_1_next_11;
history_4 = history_4_next_14;
history_3 = history_3_next_13;
history_2 = history_2_next_12;

  return Yn;
}

//=====================================
//  3.
//=====================================
//  ALLPASS
//=====================================
//=====================================

allpass_T60(Xn, ms, T60)

{
Delay delay_1(samplerate);
del_time = ms * (samplerate / 1000.);

potenza = ((-3. * (del_time / 1000.))) / T60;
g = pow(10., potenza);
menog = (-1.) * g;
feedback = (delay_1.read(del_time)) * menog;

  Yn = (delay_1.read(del_time)) + ((feedback + Xn) * g);

delay_1.write(feedback + Xn);

    return Yn;
}

//=====================================
//=====================================

allpass_g(Xn, ms, gain)

{
Delay delay_1(samplerate);
del_time = ms * (samplerate / 1000.);
g = clamp(gain, 0., 0.999);
menog = (-1.) * g;
feedback = (delay_1.read(del_time)) * menog;

  Yn = (delay_1.read(del_time)) + ((feedback + Xn) * g);

delay_1.write(feedback + Xn);

    return Yn;
}

//=====================================
//  4.
//=====================================
//  COMB FILTER
//=====================================
//=====================================

comb_iir(Xn, ms, gain)

Delay delay_1(samplerate);
del_time = ms * samplerate / 1000.;

feedback = (delay_1.read(del_time)) * gain;

Yn = Xn + feedback;

return Yn;

delay_1.write(Yn);//IIR

//=====================================
//=====================================

comb_fir(Xn, ms, gain)
{
Delay delay_1(samplerate);
del_time = ms * samplerate / 1000.;

feedback = (delay_1.read(del_time)) * gain;

Yn = Xn + feedback;

return add_5;

delay_1.write(Xn); //FIR
}
//=====================================
//=====================================

fbcomb(Xn, ms, gain)

{
Delay delay_1(samplerate);
del_time = ms * (samplerate / 1000.);
g = clamp(gain, 0., 0.9999);
feedback = (delay_1.read(del_time)) * g;

  Yn= Xn+feedback;

delay_1.write(Yn);

    return Yn;
}

//=====================================
//=====================================

fbcomb_lp(Xn, ms, T60, freqcut)

{
Delay delay_1(samplerate);
History history_1(0);

//=====================================
// COMB_IIR
//=====================================
del_time = ms * (samplerate / 1000.);
potenza = ((-3. * (del_time / 1000.))) / T60;
g = pow(10., potenza);

feedback = (delay_1.read(del_time)) * g;

//=====================================
// LOWPASS
//=====================================
omega = ((freqcut * twopi)) / samplerate;
cosw = cos(omega);
cosq = cosw * cosw;
alpha = (cosw - 1.) + (sqrt((cosq - (4. * cosw)) + 3.));
mul_1 = (1. - alpha) * history_1;

  LP = mul_1 + (feedback * alpha);
//=====================================

  Yn= Xn+LP;

delay_1.write(Yn);
history_1_2 = fixdenorm(LP);
history_1 = history_1_2;
    return Yn;
}

//=====================================
//=====================================


fbcomb_lp_all(Xn, ms, T60, freqcut)

{
Delay delay_1(samplerate);
Delay delay_2(samplerate);
History history_1(0);

//=====================================
// COMB_IIR
//=====================================
del_time = ms * (samplerate / 1000.);
potenza = ((-3. * (del_time / 1000.))) / T60;
g = pow(10., potenza);

feedback = (delay_1.read(del_time)) * g;

//=====================================
// LOWPASS
//=====================================
omega = ((freqcut * twopi)) / samplerate;
cosw = cos(omega);
cosq = cosw * cosw;
alpha = (cosw - 1.) + (sqrt((cosq - (4. * cosw)) + 3.));
mul_1 = (1. - alpha) * history_1;

  LP = mul_1 + (feedback * alpha);
//=====================================
// ALLPASS
//=====================================
//=====================================
menog = (-1.) * g;
feedback_all = (delay_2.read(del_time2)) * menog;

  allpass = (delay_2.read(del_time)) + ((feedback_all + LP) * g);

delay_2.write(feedback_all + LP);
//=====================================

  Yn= Xn + allpass;

delay_1.write(feedback);
delay_2.write(feedback_all + LP);
history_1_2 = fixdenorm(LP);
history_1 = history_1_2;
    return Yn;
}
